# -*- coding:utf-8 -*-
'''
《连续子数组的最大和》
题目描述
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。
今天测试组开完会后,他又发话了:在古老的一维模式识别中,
常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。
但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？
例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
'''

'''
解题思路：
顺着加，如果加和为负值了，就抛弃这些数字，从下一个重新开始
加和的结果是正数时，记录下来，并根据大小更新最大值，一直找到最后
时间复杂度O(n)

'''
# [1,-2,3,10,-4,7,2,-5]
# [-2,-8,-1,-5,-9]
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array:
            return

        Max = 0
        tmp = 0
        for item in array:
            if tmp < 0:
                if item > tmp:
                    Max = item  # 如果Max不是正数了，就从当前值重新开始加
                    tmp = item
            else:
                tmp = tmp + item
                if tmp > Max:   # 如果加上当前值之后和变大了，就保存这个更大的和
                    Max = tmp
        return Max
