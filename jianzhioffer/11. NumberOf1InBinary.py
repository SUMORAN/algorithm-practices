# -*- coding:utf-8 -*-

"""《二进制中1的个数》
    题目描述
    输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

    解题思路：
    本题从位运算的角度去做，这应该也是题目想要考察的，如下：
        n = (n - 1) & n：
        如果一个整数不为0，那么这个整数至少有一位是1。
        如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。
        其余所有位将不会受到影响。
        举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。
        减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.
        我们发现减1的结果是把最右边的一个1开始的所有位都取反了。
        这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。
        如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.
        那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

    用python也可以取巧，直接将二进制数字当字符串，用count("1")数出来1的个数,甚至还可以将“0b”和“0”都换成""，然后算字符串长度

    在python中，负数和0xffffffff按位与之后变成一个无符号数，二进制表示为编码形式
    0xffffffff = 1111 1111 1111 1111 1111 1111 1111 1111 (8个F的二进制形式, 一个F占4个字节 ) 
        即32位数都是1的二进制数 也就是2^32

import sys
max = sys.maxsize
"""

class Solution:
    def NumberOf1(self, n):
        count = 0
        if n<0:
            n = n & 0xffffffff
            # or n = n + 2**32
        nbin = bin(n)
        while(n!=0):
            count += 1
            n = n & (n-1)
        # while can be replaced by:
        # count = nbin.count("1") 
        # or replaced by:
        # count = len(nbin.replace("0b","").replace("0",""))
        return count